/**
 * User Profile Service - Comprehensive API client for user profile and saved texts operations
 *
 * This service centralizes all HTTP requests related to user profile management
 * and saved text library operations. It consolidates functionality that enables
 * users to manage their profile information and text library.
 *
 * Architecture:
 * - Uses the centralized Axios instance configured with JWT authentication
 * - All requests include httpOnly cookies automatically (withCredentials: true)
 * - Error handling is managed by global Axios interceptors
 * - All methods are properly typed with TypeScript for type safety
 *
 * Features:
 * - Fetch user profile data (GET /api/users/profile)
 * - Update user profile data (PUT /api/users/profile)
 * - Fetch saved texts from user's library (GET /api/users/saved-texts)
 * - Create new saved text (POST /api/users/saved-texts)
 * - Update existing saved text (PUT /api/users/saved-texts/:id)
 * - Delete saved text (DELETE /api/users/saved-texts/:id)
 *
 * Security:
 * - JWT tokens are managed via httpOnly cookies (automatic authentication)
 * - Backend validates user ownership before any modification
 * - All requests require authentication (401 if not authenticated)
 *
 * Usage:
 * ```typescript
 * import userProfileService from '@/services/userProfileService'
 *
 * // Fetch user profile
 * const profile = await userProfileService.fetchProfile()
 *
 * // Update profile
 * const updated = await userProfileService.updateProfile({
 *   firstName: 'Jane',
 *   bio: 'Travel enthusiast'
 * })
 *
 * // Fetch saved texts
 * const texts = await userProfileService.fetchSavedTexts()
 *
 * // Save new text
 * const newText = await userProfileService.saveText({
 *   label: 'My Quote',
 *   type: 'citation',
 *   content: { text: '...', fontFamily: 'Arial', fontSize: 14, fill: '#000' }
 * })
 * ```
 *
 * Convention de nommage :
 * - Fonctions : verbe + nom en camelCase (fetchProfile, updateProfile, saveText)
 * - Variables : camelCase (profileData, textId, updates)
 * - Interfaces : PascalCase (UserProfileResponse, SavedTextResponse)
 *
 * @module services/userProfileService
 */

import apiClient from './api'
import type {
  User,
  UpdateProfileData,
  ISavedText
} from '@/types/models'

// ========================================
// TYPE DEFINITIONS
// ========================================

/**
 * Type for creating/saving a new text (omits auto-generated fields)
 *
 * When creating a new saved text, the id, createdAt, and updatedAt
 * are generated by the backend, so we omit them from the request.
 */
type SaveTextData = Omit<ISavedText, 'id' | 'createdAt' | 'updatedAt'>

/**
 * Type for partial updates to existing text
 *
 * All fields are optional since we support partial updates.
 * The id, createdAt, and updatedAt cannot be modified by the user.
 */
type UpdateTextData = Partial<Omit<ISavedText, 'id' | 'createdAt' | 'updatedAt'>>

/**
 * API Response for profile fetch operation
 *
 * Standard backend response structure with success flag and user data
 */
interface UserProfileResponse {
  /** Indicates if the operation was successful */
  success: boolean

  /** User profile data */
  user: User
}

/**
 * API Response for profile update operation
 *
 * Includes success message and updated user data
 */
interface UpdateProfileResponse {
  /** Indicates if the operation was successful */
  success: boolean

  /** Confirmation message from backend */
  message: string

  /** Updated user profile data with new timestamps */
  user: User
}

/**
 * API Response for single saved text operation
 *
 * Used for create and update operations
 */
interface SavedTextResponse {
  /** Indicates if the operation was successful */
  success: boolean

  /** Confirmation message from backend */
  message: string

  /** Saved text data (with id and timestamps for create/update) */
  data: ISavedText
}

/**
 * API Response for saved texts list
 *
 * Used for fetch all saved texts operation
 */
interface SavedTextsResponse {
  /** Indicates if the operation was successful */
  success: boolean

  /** Confirmation message from backend */
  message: string

  /** Array of all saved texts for the authenticated user */
  data: ISavedText[]
}

/**
 * API Response for delete operation
 *
 * Simple success confirmation
 */
interface DeleteResponse {
  /** Indicates if the operation was successful */
  success: boolean

  /** Confirmation message from backend */
  message: string
}

// ========================================
// USER PROFILE SERVICE
// ========================================

/**
 * User Profile Service - handles all user profile and saved texts API operations
 *
 * This service object contains all methods for interacting with the backend
 * user profile and text library endpoints. All methods are asynchronous and
 * return Promises that resolve with the requested data or reject with errors.
 *
 * Error handling:
 * - Errors are logged to console for debugging
 * - Errors are propagated to the caller for handling (try/catch in store)
 * - Global Axios interceptors handle common errors (401, 403, 500, network)
 */
const userProfileService = {
  // ========================================
  // PROFILE OPERATIONS
  // ========================================

  /**
   * Fetch user profile data
   *
   * Retrieves complete profile information for the authenticated user,
   * including personal details, avatar, and metadata.
   *
   * This method is called:
   * - On application startup (session restoration)
   * - After profile updates to refresh data
   * - When navigating to profile settings page
   *
   * Endpoint: GET /api/users/profile
   * Authentication: Required (JWT via httpOnly cookies)
   * Status: 200 OK if successful, 401 if not authenticated, 404 if user not found
   *
   * @returns Promise<User> - Complete user profile data
   * @throws AxiosError if authentication fails (401) or server error (500)
   *
   * @example
   * ```typescript
   * try {
   *   const profile = await userProfileService.fetchProfile()
   *   console.log('User profile:', profile.firstName, profile.lastName)
   *   console.log('Email:', profile.email)
   *   console.log('Bio:', profile.bio)
   *   if (profile.avatarBase64) {
   *     console.log('Avatar available')
   *   }
   * } catch (err) {
   *   if (err.response?.status === 401) {
   *     console.error('User not authenticated - redirect to login')
   *   } else {
   *     console.error('Failed to fetch profile:', err.message)
   *   }
   * }
   * ```
   */
  async fetchProfile(): Promise<User> {
    try {
      // Send GET request to fetch profile endpoint
      // withCredentials: true is already set globally in apiClient,
      // but we specify it explicitly for clarity
      const response = await apiClient.get<UserProfileResponse>('/users/profile', {
        withCredentials: true
      })

      // Extract and return user data from response
      // Backend returns { success: true, user: { ... } }
      if (response.data && response.data.user) {
        return response.data.user
      }

      // Fallback error if response structure is unexpected
      throw new Error('Unexpected response structure from fetchProfile')
    } catch (error) {
      // Log error for debugging (helps novice developers understand what went wrong)
      console.error('Error fetching user profile:', error)

      // Re-throw error for caller to handle (typically the Pinia store)
      // This allows the store to update loading state and show user-friendly messages
      throw error
    }
  },

  /**
   * Update user profile data
   *
   * Modifies user profile information with the provided fields.
   * Only the fields included in profileData will be updated (partial update).
   * The backend validates all changes and enforces uniqueness constraints
   * for email and pseudo fields.
   *
   * Validation:
   * - Email: Must be valid format and unique across all users
   * - Pseudo: Must be 3-20 alphanumeric characters and unique
   * - Bio: Maximum 160 characters
   * - AvatarBase64: Maximum 2MB, must be valid base64 image data
   *
   * Endpoint: PUT /api/users/profile
   * Authentication: Required (JWT via httpOnly cookies)
   * Status: 200 OK if successful, 400 if validation fails, 409 if email/pseudo already exists
   *
   * @param profileData - Fields to update (all optional)
   *   - firstName?: User's first name
   *   - lastName?: User's last name
   *   - email?: New email address (must be unique)
   *   - pseudo?: New username (must be unique)
   *   - bio?: Biography text (max 160 chars)
   *   - avatarBase64?: Profile picture in base64 format (max 2MB)
   *
   * @returns Promise<User> - Updated user profile with new timestamps
   * @throws AxiosError if validation fails (400), email/pseudo exists (409), unauthorized (401)
   *
   * @example
   * ```typescript
   * try {
   *   const updatedProfile = await userProfileService.updateProfile({
   *     firstName: 'Jane',
   *     bio: 'Passionate traveler and photographer',
   *     avatarBase64: 'data:image/jpeg;base64,/9j/4AAQSkZJRg...'
   *   })
   *   console.log('Profile updated successfully')
   *   console.log('New name:', updatedProfile.firstName, updatedProfile.lastName)
   *   console.log('Updated at:', updatedProfile.updatedAt)
   * } catch (err) {
   *   if (err.response?.status === 409) {
   *     console.error('Email or pseudo already in use')
   *   } else if (err.response?.status === 400) {
   *     console.error('Validation failed:', err.response.data.message)
   *   } else {
   *     console.error('Failed to update profile:', err.message)
   *   }
   * }
   * ```
   */
  async updateProfile(profileData: UpdateProfileData): Promise<User> {
    try {
      // Send PUT request to update profile endpoint with provided data
      // Only the fields in profileData will be updated
      const response = await apiClient.put<UpdateProfileResponse>(
        '/users/profile',
        profileData,
        {
          withCredentials: true
        }
      )

      // Extract and return updated user data
      // Backend returns { success: true, message: '...', user: { ... } }
      if (response.data && response.data.user) {
        return response.data.user
      }

      // Fallback error if response structure is unexpected
      throw new Error('Unexpected response structure from updateProfile')
    } catch (error) {
      // Log error for debugging
      console.error('Error updating user profile:', error)

      // Re-throw error for caller to handle
      throw error
    }
  },

  // ========================================
  // SAVED TEXTS OPERATIONS
  // ========================================

  /**
   * Fetch all saved texts for authenticated user
   *
   * Retrieves all text entries from the user's saved text library.
   * Each text contains complete formatting information (font, size, color, alignment, etc.)
   * that can be reused when creating new page elements.
   *
   * Use cases:
   * - Populating the text library panel in the editor
   * - Displaying saved quotes/poems in user's library view
   * - Auto-loading texts on application startup
   *
   * Endpoint: GET /api/users/saved-texts
   * Authentication: Required (JWT via httpOnly cookies)
   * Status: 200 OK if successful, 401 if unauthorized, 500 if server error
   *
   * @returns Promise<ISavedText[]> - Array of saved texts with formatting info
   * @throws AxiosError if request fails (handled by global interceptor)
   *
   * @example
   * ```typescript
   * try {
   *   const texts = await userProfileService.fetchSavedTexts()
   *   console.log('Found', texts.length, 'saved texts')
   *
   *   // Display each text
   *   texts.forEach(text => {
   *     console.log(`${text.label} (${text.type}):`, text.content.text)
   *     console.log('  Font:', text.content.fontFamily, text.content.fontSize)
   *     console.log('  Color:', text.content.fill)
   *   })
   *
   *   // Structure of each text:
   *   // {
   *   //   id: 'uuid-123',
   *   //   label: 'My Citation',
   *   //   type: 'citation',
   *   //   content: {
   *   //     text: 'The only way to do great work...',
   *   //     fontFamily: 'Arial',
   *   //     fontSize: 14,
   *   //     fill: '#000000',
   *   //     textAlign: 'center',
   *   //     fontWeight: 'bold'
   *   //   },
   *   //   createdAt: '2025-01-15T10:30:00Z',
   *   //   updatedAt: '2025-01-15T10:30:00Z'
   *   // }
   * } catch (err) {
   *   if (err.response?.status === 401) {
   *     console.error('User not authenticated')
   *   } else {
   *     console.error('Failed to fetch saved texts:', err.message)
   *   }
   * }
   * ```
   */
  async fetchSavedTexts(): Promise<ISavedText[]> {
    try {
      // Send GET request to fetch all saved texts
      const response = await apiClient.get<SavedTextsResponse>('/users/saved-texts')

      // Extract and return the array of saved texts from response data
      // Backend returns { success: true, message: '...', data: [...] }
      if (response.data && response.data.data) {
        return response.data.data
      }

      // Fallback to empty array if structure is unexpected
      // This prevents crashes when the backend response format changes
      console.warn('Unexpected response structure for fetchSavedTexts')
      return []
    } catch (error) {
      // Log error for debugging
      console.error('Error fetching saved texts:', error)

      // Re-throw error for caller to handle
      throw error
    }
  },

  /**
   * Create and save new text to user's library
   *
   * Saves a new text entry to the user's text library with complete formatting information.
   * The text can be a citation, poem, or free-form text with custom styling.
   *
   * Validation:
   * - Label: Required, max 100 characters
   * - Type: Must be 'citation', 'poeme', or 'libre'
   * - Content.text: Required, max 1000 characters
   * - Content.fontFamily: Required, must be a valid Google Font name
   * - Content.fontSize: Required, 8-200 pixels
   * - Content.fill: Required, valid hex color (#RRGGBB)
   * - Other content fields: Optional (textAlign, fontWeight, fontStyle, etc.)
   *
   * Endpoint: POST /api/users/saved-texts
   * Authentication: Required (JWT via httpOnly cookies)
   * Status: 201 Created if successful, 400 if validation fails, 401 if unauthorized
   *
   * @param textData - Text content and formatting info
   *   - label: Text identifier/title (max 100 chars)
   *   - type: 'citation' | 'poeme' | 'libre'
   *   - content: ITextContent with formatting properties
   *
   * @returns Promise<ISavedText> - Created text with generated id and timestamps
   * @throws AxiosError if request fails (validation or server error)
   *
   * @example
   * ```typescript
   * try {
   *   const newText = await userProfileService.saveText({
   *     label: 'Steve Jobs Quote',
   *     type: 'citation',
   *     content: {
   *       text: 'The only way to do great work is to love what you do.',
   *       fontFamily: 'Georgia',
   *       fontSize: 16,
   *       fill: '#333333',
   *       textAlign: 'center',
   *       fontWeight: 'bold',
   *       fontStyle: 'italic'
   *     }
   *   })
   *   console.log('Text saved successfully with ID:', newText.id)
   *   console.log('Created at:', newText.createdAt)
   *
   *   // Now you can reuse this text in pages
   *   // The newText object contains all formatting info
   * } catch (err) {
   *   if (err.response?.status === 400) {
   *     console.error('Validation failed:', err.response.data.message)
   *     // Example errors:
   *     // - "Label is required and cannot be empty"
   *     // - "Text content exceeds maximum length of 1000 characters"
   *     // - "Invalid font size, must be between 8 and 200"
   *   } else if (err.response?.status === 401) {
   *     console.error('User not authenticated')
   *   } else {
   *     console.error('Failed to save text:', err.message)
   *   }
   * }
   * ```
   */
  async saveText(textData: SaveTextData): Promise<ISavedText> {
    try {
      // Send POST request to create new saved text
      // Backend will validate the data and generate id, createdAt, updatedAt
      const response = await apiClient.post<SavedTextResponse>('/users/saved-texts', textData)

      // Extract and return the created text with id and timestamps
      // Backend returns { success: true, message: '...', data: { id, ..., createdAt, updatedAt } }
      if (response.data && response.data.data) {
        return response.data.data
      }

      // Fallback error if response structure is unexpected
      throw new Error('Unexpected response structure from saveText')
    } catch (error) {
      // Log error for debugging
      console.error('Error saving text:', error)

      // Re-throw error for caller to handle
      throw error
    }
  },

  /**
   * Update existing saved text
   *
   * Modifies an existing text entry in the user's library. Only provided fields
   * are updated (partial update). The backend validates all changes and prevents
   * unauthorized modifications (users can only update their own texts).
   *
   * Validation:
   * - Same validation rules as saveText apply to modified fields
   * - The backend verifies that the text belongs to the authenticated user
   * - The id, createdAt, and updatedAt cannot be manually modified
   *
   * Endpoint: PUT /api/users/saved-texts/:id
   * Authentication: Required (JWT via httpOnly cookies)
   * Status: 200 OK if successful, 404 if text not found, 401 if unauthorized
   *
   * @param textId - UUID of the text to update
   * @param updates - Fields to modify (all optional)
   *   - label?: New text identifier
   *   - type?: New type (citation/poeme/libre)
   *   - content?: Updated formatting info (partial or complete)
   *
   * @returns Promise<ISavedText> - Updated text with new updatedAt timestamp
   * @throws AxiosError if text not found (404), unauthorized (401), or server error
   *
   * @example
   * ```typescript
   * try {
   *   // Update only the label
   *   const updated1 = await userProfileService.updateText(textId, {
   *     label: 'Updated Quote Title'
   *   })
   *
   *   // Update only font size in content
   *   const updated2 = await userProfileService.updateText(textId, {
   *     content: {
   *       ...existingContent,
   *       fontSize: 18  // Change only font size, keep other properties
   *     }
   *   })
   *
   *   // Update multiple fields
   *   const updated3 = await userProfileService.updateText(textId, {
   *     label: 'New Title',
   *     type: 'poeme',
   *     content: {
   *       text: 'Updated text content...',
   *       fontFamily: 'Times New Roman',
   *       fontSize: 14,
   *       fill: '#000000'
   *     }
   *   })
   *
   *   console.log('Text updated, new timestamp:', updated3.updatedAt)
   * } catch (err) {
   *   if (err.response?.status === 404) {
   *     console.error('Text not found - may have been deleted')
   *   } else if (err.response?.status === 401) {
   *     console.error('Unauthorized - this is not your text')
   *   } else if (err.response?.status === 400) {
   *     console.error('Validation failed:', err.response.data.message)
   *   } else {
   *     console.error('Failed to update text:', err.message)
   *   }
   * }
   * ```
   */
  async updateText(textId: string, updates: UpdateTextData): Promise<ISavedText> {
    try {
      // Send PUT request to update existing saved text
      // The textId in the URL identifies which text to update
      // Only the fields in updates will be modified
      const response = await apiClient.put<SavedTextResponse>(
        `/users/saved-texts/${textId}`,
        updates
      )

      // Extract and return the updated text
      // Backend returns { success: true, message: '...', data: { ..., updatedAt: 'new timestamp' } }
      if (response.data && response.data.data) {
        return response.data.data
      }

      // Fallback error if response structure is unexpected
      throw new Error('Unexpected response structure from updateText')
    } catch (error) {
      // Log error for debugging
      console.error('Error updating text:', error)

      // Re-throw error for caller to handle
      throw error
    }
  },

  /**
   * Delete saved text from user's library
   *
   * Removes a text entry from the user's library permanently. Once deleted, the text
   * cannot be recovered. The backend verifies ownership before deletion to prevent
   * unauthorized access.
   *
   * Security:
   * - Users can only delete their own texts (ownership verified by backend)
   * - JWT authentication required
   * - Soft delete (paranoid) may be implemented on backend for data recovery
   *
   * Endpoint: DELETE /api/users/saved-texts/:id
   * Authentication: Required (JWT via httpOnly cookies)
   * Status: 204 No Content if successful, 404 if text not found, 401 if unauthorized
   *
   * @param textId - UUID of the text to delete
   * @returns Promise<void> - Resolves when deletion is complete (no return value)
   * @throws AxiosError if text not found (404), unauthorized (401), or server error
   *
   * @example
   * ```typescript
   * try {
   *   await userProfileService.deleteText(textId)
   *   console.log('Text deleted successfully')
   *
   *   // Remove from local state (typically done in Pinia store)
   *   // savedTexts.value = savedTexts.value.filter(t => t.id !== textId)
   * } catch (err) {
   *   if (err.response?.status === 404) {
   *     console.error('Text not found - may have been already deleted')
   *   } else if (err.response?.status === 401) {
   *     console.error('Unauthorized - this is not your text')
   *   } else {
   *     console.error('Failed to delete text:', err.message)
   *   }
   * }
   * ```
   */
  async deleteText(textId: string): Promise<void> {
    try {
      // Send DELETE request to remove saved text
      // The textId in the URL identifies which text to delete
      // No request body is needed for DELETE operations
      await apiClient.delete<DeleteResponse>(`/users/saved-texts/${textId}`)

      // Deletion successful - backend returns 204 No Content (no response body)
      // Log success for debugging
      console.debug('Text deleted successfully:', textId)
    } catch (error) {
      // Log error for debugging
      console.error('Error deleting text:', error)

      // Re-throw error for caller to handle
      throw error
    }
  }
}

/**
 * Export the user profile service as default
 *
 * Utilisation dans les stores et composants :
 * ```typescript
 * import userProfileService from '@/services/userProfileService'
 *
 * // In Pinia store
 * const profile = await userProfileService.fetchProfile()
 *
 * // In Vue component
 * const texts = await userProfileService.fetchSavedTexts()
 * ```
 */
export default userProfileService
